/*
 * This is the entry point for our Node server. It is a "server runtime" as far
 * as React is concerned. Because it is a server runtime, it can render server
 * components but not client components.
 */

import { serve } from "@hono/node-server";
import { serveStatic } from "@hono/node-server/serve-static";
import { type Context, type Next, Hono } from "hono";
import { createServer as createHttpServer } from "node:http";
import { basename } from "node:path";
import { PassThrough, Readable } from "node:stream";
import {
  decodeReply,
  renderToPipeableStream,
} from "react-server-dom-webpack/server";

import { parse } from "./Argv.js";
import { App } from "./App.js";
import { Document } from "./Document.js";
import { Environment } from "./Environment.js";
import { Home } from "./Home/Home.js";
import { manifest } from "./RscRuntimeServer.js";
import { Post } from "./Post/Post.js";
import { Posts } from "./Posts/Posts.js";
import { createTransform } from "./TextTransform.js";
import { Uint8ArraySink } from "./Uint8ArraySink.js";
import { fromFile, getEntryChunk } from "./ViteManifest.js";

// the environment is passed as a command line arg for the purposes of this demo
const { env: environment } = parse(process.argv);

// in prod we need the build manifest generated by Vite
const viteManifest =
  environment !== Environment.Development
    ? fromFile("./build/browser-client/.vite/manifest.json")
    : null;

// in dev we use the Vite dev server to load our client modules.
const Vite =
  environment === Environment.Development
    ? await import("./ViteRuntime.js")
    : null;

// Vite produces 2 client bundles, one for SSR and one for the browser. The SSR
// bundle has its own build manifest.
const viteSsrManifest =
  environment !== Environment.Development
    ? fromFile("./build/node-client/.vite/manifest.json")
    : null;

type NodeClient = typeof import("./NodeClient.js");

// in dev we use Vite to load our Node client. In prod we import the bundle
// directly.
const { renderToHtml } = Vite
  ? await Vite.runtime.executeUrl<NodeClient>("./NodeClient.tsx")
  : ((await import(
      /* @vite-ignore */ `../node-client/${
        getEntryChunk(viteSsrManifest!).file
      }`
    )) as NodeClient);

type Variables = {
  forwardedUrl: string;
};

interface HonoContext extends Context<{ Variables: Variables }> {}

const app = new Hono();

app.use("*", setForwardedUrl);

// We use Vite to build both our Node server and our browser client. We may end
// up with static assets from either of those builds.
app.get("/assets/*", serveStatic({ root: "./build/node-server" }));
app.get("/assets/*", serveStatic({ root: "./build/browser-client" }));

// all other GET request will render our application on the server to send HTML
// to the browser.
app.get("*", ssr);

// creates an endpoint to call a server action
app.post("/action", callServerAction);

// creates an endpoint to render a server component
app.post("/render", renderServerComponent);

// A wrapper around Node's `createServer` to insert Vite middleware in dev.
// This is necessary since Vite uses Node's internal HTTP Req/Res types but Hono
// uses web standard Req/Res types. This makes Vite middleware incompatible
// with Hono middleware.
const createServer = ((options, listener) => {
  if (Vite)
    return createHttpServer(options, (req, res) =>
      Vite.server.middlewares.handle(req, res, () => listener?.(req, res))
    );

  return createHttpServer(options, listener);
}) as typeof createHttpServer;

const server = serve({
  createServer,
  fetch: app.fetch,
  port: 4000,
});

// Calls a server action. This was taken from Kent C. Dodds' workshop on server
// components.
async function callServerAction(context: HonoContext, _next: Next) {
  const serverReference = context.req.header("rsc-action");
  const [filepath, name] = serverReference!.split("#");
  let filename = basename(filepath!);

  // in dev we use vite-node which understands TypeScript. However, in prod we
  // just use node so the extension needs to be .js
  if (environment !== Environment.Development)
    filename = filename.replace(/\.tsx?$/, ".js");

  const action = (await import(/* @vite-ignore */ `./${filename}`))[name!];

  // Validate that this is actually a function we intended to expose and
  // not the client trying to invoke arbitrary functions. In a real app,
  // you'd have a manifest verifying this before even importing it.
  if (action.$$typeof !== Symbol.for("react.server.reference")) {
    throw new Error("Invalid action");
  }

  const formData = await context.req.text();
  const args = await decodeReply<any[]>(formData);
  const result = await action(...args);
  const { pipe } = renderToPipeableStream(result, manifest);
  const rscPayload = pipe(new PassThrough());

  return context.newResponse(Readable.toWeb(rscPayload) as ReadableStream);
}

// Renders a server component. I'm using the react-distributed-components
// library to enable rendering server components from client components. When
// ever a server component needs to be rendered, that library will call this
// endpoint.
// see file://./App.tsx ServerComponentContext
async function renderServerComponent(context: HonoContext, _next: Next) {
  type Body =
    | { type: "Home"; props: Home.Props }
    | { type: "Post"; props: Post.Props }
    | { type: "Posts"; props: Posts.Props };

  const body = await decodeReply<Body>(await context.req.text());
  const { type, props } = body;

  const Component = () => {
    switch (type) {
      case "Home":
        return <Home {...props} />;
      case "Post":
        return <Post {...props} />;
      case "Posts":
        return <Posts {...props} />;
    }
  };

  const { pipe } = renderToPipeableStream(<Component />, manifest);
  const rscPayload = pipe(new PassThrough());

  return context.newResponse(Readable.toWeb(rscPayload) as ReadableStream);
}

/*
 * Fly.io's reverse proxy will downgrade requests to HTTP. However, when
 * providing links to the client we want to use the forwarded URL to prevent
 * downgrading to HTTP.
 */
function setForwardedUrl(context: Context, next: Next) {
  const url = new URL(context.req.url);
  url.protocol = context.req.header("X-Forwarded-Proto") ?? url.protocol;
  context.set("forwardedUrl", url.href);
  return next();
}

// Renders our entire applications on the server (both server components and
// client components) and returns HTML to the browser.
function ssr(context: HonoContext, _next: Next) {
  const document = (
    <Document
      environment={environment}
      entry={viteManifest ? `/${getEntryChunk(viteManifest).file}` : undefined}
    >
      <App url={context.get("forwardedUrl")} />
    </Document>
  );

  const { pipe } = renderToPipeableStream(document, manifest);
  const rscPayload = pipe(new PassThrough());
  const rscPayloadBuffer = rscPayload.pipe(new Uint8ArraySink());

  const html = Readable.toWeb(
    renderToHtml(rscPayload, context.req.url).pipe(
      // Embeds the RSC payload in the document so the app can be hydrated on
      // the client.
      createTransform(
        "</body>",
        () => /* HTML */ `
            <script id="rsc_payload" type="json">
              ${JSON.stringify([...rscPayloadBuffer.data])}
            </script>
          </body>
        `
      )
    )
  ) as ReadableStream;

  context.header("Content-Encoding", "gzip");
  context.header("Content-Type", "text/html; charset=UTF-8");
  return context.newResponse(html.pipeThrough(new CompressionStream("gzip")));
}

if (import.meta.hot) {
  // stops the server to prevent `EADDRINUSE` errors during HMR. This kinda
  // works but not always. I think the problem may be that stopping the server
  // is asynchronous instead of synchronous but I'm not sure to be honest.
  import.meta.hot.accept(() => {
    server.close();
  });
}
